<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Neon Realms — Level 5 (First Ride)</title>
  <style>
    html, body { height:100%; margin:0; background:#0a0a12; color:#e8f0ff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }
    #hud { position:fixed; left:8px; top:8px; z-index:11; background:#101022; border:1px solid #2b2b64; border-radius:10px; padding:8px 10px; font-size:12px; opacity:.96; min-width: 220px; }
    #hud .row { display:flex; justify-content:space-between; gap:10px; align-items:center; }
    #buttons { position:fixed; left:12px; bottom:16px; display:flex; gap:8px; z-index:10; }
    .btn { width:64px; height:64px; border-radius:14px; border:1px solid #2b2b64;
      background:radial-gradient(100% 100% at 50% 0%, #1a1a36 0%, #0e0e1f 100%); color:#bfe2ff; font-weight:800; font-size:10px; }
    #dashBtn { position:fixed; right:12px; bottom:88px; width:64px; height:64px; border-radius:14px; border:1px solid #2b2b64;
      background:radial-gradient(100% 100% at 50% 0%, #1a1a36 0%, #0e0e1f 100%); color:#bfe2ff; font-weight:800; font-size:10px; display:block; z-index:10; }
    #jumpBtn { position:fixed; right:12px; bottom:16px; }
    #overlay { position:fixed; inset:0; display:none; z-index:20; align-items:center; justify-content:center; background:rgba(8,8,16,0.55); }
    #overlay .card { background:#0d0d1fdd; border:1px solid #63d7ff; color:#e8f0ff; padding:16px 22px; border-radius:14px; text-align:center; min-width:320px; }
    #overlay h2 { margin:0 0 8px 0; font-size:22px; }
    #overlay p  { margin:6px 0; font-size:14px; color:#bfe2ff; }
    #overlay .score { font-size:28px; margin-top:8px; }
    #overlay .btnbar { margin-top:12px; display:flex; gap:8px; justify-content:center; }
    #overlay button { padding:8px 12px; border-radius:10px; border:1px solid #2b2b64; background:#131333; color:#cfe9ff; font-weight:700; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="hud">
    <div class="row"><span id="levelLbl">Level 1/5</span><span id="dashLbl">Dash: READY</span></div>
    <div class="row"><span id="deathLbl">Deaths: 0</span><span id="timerLbl">Time: 0.00</span></div>
  </div>

  <div id="buttons">
    <button class="btn" id="leftBtn">LEFT</button>
    <button class="btn" id="rightBtn">RIGHT</button>
    <button class="btn" id="jumpBtn">JUMP</button>
  </div>
  <button id="dashBtn">DASH</button>

  <div id="overlay">
    <div class="card" id="card">
      <h2 id="ovTitle">Level Complete!</h2>
      <p id="ovBody"></p>
      <div class="score" id="ovScore">Score: 0</div>
      <p id="ovPB"></p>
      <div class="btnbar" id="ovBtns">
        <button id="nextBtn">Next</button>
        <button id="retryBtn">Retry</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false });
  function resize(){ canvas.width = Math.floor(innerWidth*DPR); canvas.height = Math.floor(innerHeight*DPR); }
  addEventListener('resize', resize); resize();

  // HUD refs
  const levelLbl = document.getElementById('levelLbl');
  const dashLbl = document.getElementById('dashLbl');
  const timerLbl = document.getElementById('timerLbl');
  const deathLbl = document.getElementById('deathLbl');
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ovTitle');
  const ovBody  = document.getElementById('ovBody');
  const ovScore = document.getElementById('ovScore');
  const ovPB    = document.getElementById('ovPB');
  const nextBtn = document.getElementById('nextBtn');
  const retryBtn= document.getElementById('retryBtn');

  // Inputs
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const jumpBtn = document.getElementById('jumpBtn');
  const dashBtn = document.getElementById('dashBtn');
  const keys = { left:false, right:false, jump:false };
  const setKey=(k,v)=>keys[k]=v;
  let jumpEdge=false, lastJumpTapMs=-1;
  function tapJump(){ jumpEdge=true; lastJumpTapMs=performance.now(); }

  function bindHold(el,key){
    el.addEventListener('pointerdown',e=>{ e.preventDefault(); setKey(key,true); if(key==='jump') tapJump(); }, {passive:false});
    el.addEventListener('pointerup',e=>{ e.preventDefault(); setKey(key,false); }, {passive:false});
    el.addEventListener('touchstart',e=>{ e.preventDefault(); setKey(key,true); if(key==='jump') tapJump(); }, {passive:false});
    el.addEventListener('touchend',e=>{ e.preventDefault(); setKey(key,false); }, {passive:false});
  }
  bindHold(leftBtn,'left'); bindHold(rightBtn,'right'); bindHold(jumpBtn,'jump');

  addEventListener('keydown',e=>{ if(e.repeat) return;
    if(e.code==='ArrowLeft'||e.code==='KeyA') setKey('left',true);
    if(e.code==='ArrowRight'||e.code==='KeyD') setKey('right',true);
    if(e.code==='Space'||e.code==='KeyW'||e.code==='ArrowUp'){ setKey('jump',true); tapJump(); }
    if(e.code==='ShiftLeft'||e.code==='ShiftRight') tryDash(player.facing||1);
  });
  addEventListener('keyup',e=>{
    if(e.code==='ArrowLeft'||e.code==='KeyA') setKey('left',false);
    if(e.code==='ArrowRight'||e.code==='KeyD') setKey('right',false);
    if(e.code==='Space'||e.code==='KeyW'||e.code==='ArrowUp') setKey('jump',false);
  });
  dashBtn.addEventListener('pointerup', e=>{ e.preventDefault(); tryDash(player.facing||1); });

  // World helpers
  const groundY=520;
  function rect(x,y,w,h){ return {t:'rect',x,y,w,h}; }
  function slope(x1,y1,x2,y2){ return {t:'slope',x1,y1,x2,y2,minX:Math.min(x1,x2),maxX:Math.max(x1,x2)}; }
  function slopeYAt(s,x){ const t=(x-s.x1)/(s.x2-s.x1); return s.y1 + t*(s.y2 - s.y1); }
  function spike(x,y,w,h){ return {t:'spike',x,y,w,h}; }
  function laser(x,y,w,h,axis='y',amp=0,speed=0){ return {t:'laser',x,y,w,h,axis,amp,speed,phase:Math.random()*Math.PI*2}; }
  function drone(x,y,minX,maxX,speed){ return {t:'drone',x,y,w:36,h:24,minX,maxX,dir:1,speed}; }
  function hover(x,y,minY,maxY,speed){ return {t:'hover',x,y,w:34,h:22,minY,maxY,dir:1,speed}; }
  function goal(x,y){ return {t:'goal',x,y,w:36,h:120}; }
  // NEW: moving platform
  function mplat(x,y,w,h,axis,min,max,speed,pause=0.2){ return {t:'mplat',x,y,w,h,axis,min,max,speed,dir:1,pause,waiting:0,prevX:x,prevY:y}; }

  // Levels 1–3 (as before)
  function buildLevel1(){
    const pads=[]; const hz=[]; const en=[];
    let x=40; while(x<3600){ const segW=420, gap=140; pads.push(rect(x, groundY, segW, 30)); x += segW + gap; }
    pads.push(slope(900, groundY+30, 1080, groundY-140));
    pads.push(rect(1400, groundY-110, 220, 18));
    pads.push(rect(1900, groundY-200, 220, 18));
    hz.push(spike(1200, groundY, 80, 40));
    hz.push(laser(2200, groundY-170, 18, 170, 'y', 80, 1.1));
    en.push(drone(1650, groundY-140, 1600, 1850, 120));
    const g = goal(3300, groundY-120);
    return {pads,hz,en,goal:g,length:3600, plats:[]};
  }
  function buildLevel2(){
    const pads=[]; const hz=[]; const en=[];
    let x=40; while(x<4200){ const segW=360, gap=160; pads.push(rect(x, groundY, segW, 30)); x += segW + gap; }
    pads.push(slope(700, groundY+30, 900, groundY-160));
    pads.push(rect(1350, groundY-140, 200, 18));
    pads.push(rect(1700, groundY-260, 200, 18));
    pads.push(rect(2300, groundY-100, 220, 18));
    hz.push(spike(1100, groundY, 100, 40));
    hz.push(laser(2000, groundY-180, 18, 220, 'y', 120, 1.5));
    hz.push(laser(2600, groundY-40, 220, 16, 'x', 100, 1.0));
    en.push(drone(1500, groundY-170, 1450, 1750, 150));
    en.push(hover(2450, groundY-200, groundY-260, groundY-120, 60));
    const g = goal(3900, groundY-120);
    return {pads,hz,en,goal:g,length:4200, plats:[]};
  }
  function buildLevel3(){
    const pads=[]; const hz=[]; const en=[];
    let x=40; while(x<4800){ const segW=320, gap=180; pads.push(rect(x, groundY, segW, 30)); x += segW + gap; }
    pads.push(slope(900, groundY+30, 1080, groundY-180));
    pads.push(rect(1500, groundY-180, 200, 18));
    pads.push(rect(1900, groundY-300, 200, 18));
    pads.push(rect(2550, groundY-220, 200, 18));
    hz.push(spike(1250, groundY, 120, 40));
    hz.push(laser(2100, groundY-200, 18, 240, 'y', 140, 1.6));
    hz.push(laser(3000, groundY-60, 260, 16, 'x', 160, 1.2));
    hz.push(spike(3400, groundY, 100, 40));
    en.push(drone(1700, groundY-210, 1650, 1950, 170));
    en.push(hover(2850, groundY-220, groundY-300, groundY-120, 70));
    en.push(drone(3300, groundY-30, 3250, 3550, 140));
    const g = goal(4500, groundY-120);
    return {pads,hz,en,goal:g,length:4800, plats:[]};
  }
  // Level 4 (slightly tougher, same ingredients)
  function buildLevel4(){
    const pads=[]; const hz=[]; const en=[];
    let x=40; while(x<5200){ const segW=340, gap=190; pads.push(rect(x, groundY, segW, 30)); x += segW + gap; }
    pads.push(slope(820, groundY+30, 1040, groundY-160));
    pads.push(rect(1320, groundY-140, 200, 18));
    pads.push(slope(1600, groundY-160, 1820, groundY+10));
    pads.push(rect(2100, groundY-180, 200, 18));
    pads.push(rect(2480, groundY-260, 200, 18));
    pads.push(rect(2950, groundY-200, 220, 18));
    pads.push(slope(3350, groundY-200, 3600, groundY+10));
    hz.push(spike(1200, groundY, 100, 40));
    hz.push(laser(2200, groundY-200, 18, 220, 'y', 120, 1.45));
    hz.push(laser(3050, groundY-50, 240, 16, 'x', 120, 1.1));
    en.push(drone(1750, groundY-170, 1700, 1950, 150));
    en.push(drone(3400, groundY-120, 3320, 3580, 160));
    const g = goal(4900, groundY-120);
    return {pads,hz,en,goal:g,length:5200, plats:[]};
  }
  // ---------- Level 5: First Ride (moving platform tutorial) ----------
  function buildLevel5(){
    const pads=[]; const hz=[]=[]; const en=[];
    // Two static ledges with a gap the platform crosses
    pads.push(rect(40, groundY, 520, 30));
    pads.push(rect(1500, groundY, 520, 30));
    // A couple mid ledges before/after to keep flow
    pads.push(rect(1150, groundY-140, 200, 18));
    pads.push(rect(1750, groundY-120, 220, 18));
    // Moving platform: slow, clear, long travel over the gap
    const plats=[];
    // axis 'x', travels between min and max; speed in px/sec; slight pause at ends
    plats.push(mplat(780, groundY-80, 200, 20, 'x', 700, 1320, 90, 0.25));
    // Goal visible across
    const g = goal(1880, groundY-120);
    return {pads,hz,en,goal:g,length:2100, plats};
  }
  // -------------------------------------------------------------------

  const LEVELS=[buildLevel1(), buildLevel2(), buildLevel3(), buildLevel4(), buildLevel5()];
  let levelIndex=0; function currentL(){ return LEVELS[levelIndex]; }

  // Player & physics
  const player={x:120,y:420,w:30,h:36,vx:0,vy:0,onGround:false,facing:1};
  const MOVE=360, G=2200, JUMP=780;
  const COYOTE=0.12; let coyote=0;

  // Dash + dash-jump
  const DASH_SPEED=1700, DASH_COOLDOWN=0.85;
  const DJ_MIN=0.06, DJ_MAX=0.30, DJ_BOOST=300;
  let dashCooldown=0, dashStartMs=-1, djDone=false;
  const TRAIL_MS=140; const trail=[];
  function tryDash(dir){
    if (dashCooldown>0) return;
    player.vx = dir * DASH_SPEED;
    dashCooldown = DASH_COOLDOWN;
    dashStartMs = performance.now();
    djDone = false;
    emitBurst(player.x+player.w/2, player.y+player.h/2, dir);
  }

  // Particles
  const particles=[];
  function emitBurst(x,y,dir){
    for(let i=0;i<12;i++){
      const a = (Math.random()*0.6 - 0.3) + (dir>0?0:Math.PI);
      const sp = 220 + Math.random()*260;
      particles.push({x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life:400, max:400, c:'#ff6fa6'});
    }
  }

  // Progress (minimal for this cut)
  let run = { deaths:0, timeStart:performance.now() };

  function respawn(start=false, death=false){
    player.x = 120; player.y = 420; player.vx=0; player.vy=0; player.onGround=false; coyote=0;
    if (death){ run.deaths++; deathLbl.textContent = 'Deaths: ' + run.deaths; screenFlash=140; }
    if (start){ camX = player.x; camY = groundY-120; }
  }

  // Camera
  let camX=0, camY=groundY-120, lookAhead=0, last=performance.now();
  const LOOK_BASE = 140, LOOK_SPEED_FACTOR = 0.35, LOOK_AIR_BONUS = 80, LOOK_SMOOTH = 7.0;

  // Screen flash on hit
  let screenFlash = 0;

  function startLevel(i){
    levelIndex = Math.max(0, Math.min(LEVELS.length-1, i));
    levelLbl.textContent = `Level ${levelIndex+1}/${LEVELS.length}`;
    respawn(true);
    run.deaths = 0;
    run.timeStart = performance.now();
    deathLbl.textContent = 'Deaths: 0';
  }
  startLevel(0);

  function updateHazards(dt, hz){
    for(const h of hz){
      if(h.t==='laser'){
        const t = performance.now()/1000 + (h.phase||0);
        h.offset = Math.sin(t*h.speed)*h.amp;
      }
    }
  }
  function updateEnemies(dt, en){
    for(const e of en){
      if(e.t==='drone'){
        e.x += e.dir * e.speed * dt;
        if(e.x < e.minX){ e.x=e.minX; e.dir=1; }
        if(e.x + e.w > e.maxX){ e.x=e.maxX - e.w; e.dir=-1; }
      } else if(e.t==='hover'){
        e.y += e.dir * e.speed * dt;
        if(e.y < e.minY){ e.y=e.minY; e.dir=1; }
        if(e.y + e.h > e.maxY){ e.y=e.maxY - e.h; e.dir=-1; }
      }
    }
  }
  // NEW: moving platforms update (carry + end pauses + no crush)
  function updatePlats(dt, plats){
    for(const p of plats){
      p.prevX = p.x; p.prevY = p.y;
      if(p.waiting>0){ p.waiting -= dt; continue; }
      if(p.axis==='x'){ p.x += p.dir * p.speed * dt;
        if(p.x < p.min){ p.x=p.min; p.dir=1; p.waiting=p.pause; }
        if(p.x > p.max){ p.x=p.max; p.dir=-1; p.waiting=p.pause; }
      } else { p.y += p.dir * p.speed * dt;
        if(p.y < p.min){ p.y=p.min; p.dir=1; p.waiting=p.pause; }
        if(p.y > p.max){ p.y=p.max; p.dir=-1; p.waiting=p.pause; }
      }
    }
  }

  function step(now){
    const dt=Math.min(0.033,(now-last)/1000); last=now;
    const L = currentL();

    // HUD
    timerLbl.textContent = 'Time: ' + ((now - run.timeStart)/1000).toFixed(2);
    dashCooldown = Math.max(0, dashCooldown - dt);
    dashLbl.textContent = 'Dash: ' + (dashCooldown>0? dashCooldown.toFixed(1)+'s' : 'READY');

    // Inputs & movement
    const dir=(keys.right?1:0) - (keys.left?1:0);
    if (dir!==0) player.facing=dir;
    player.vx += (dir*360 - player.vx)*0.30;
    player.vy += 2200*dt;
    if (player.onGround) coyote = 0.12; else coyote = Math.max(0, coyote - dt);
    if (jumpEdge && (player.onGround || coyote>0)){ player.vy = -780; coyote=0; }
    jumpEdge=false;

    // Dash-jump window (keep existing timing feel)
    const djDelta = (lastJumpTapMs>0 && dashStartMs>0) ? (lastJumpTapMs - dashStartMs) : -1e9;
    if (!djDone && djDelta >= 0.06*1000 && djDelta <= 0.30*1000){
      player.vy = Math.min(player.vy,0) - 300; djDone = true;
    }

    // Update hazards/enemies/platforms
    updateHazards(dt, L.hz);
    updateEnemies(dt, L.en);
    updatePlats(dt, L.plats);

    // Trail particles (dash)
    const nowMs = performance.now();
    if(dashStartMs>0 && nowMs-dashStartMs<140){
      trail.push({x:player.x, y:player.y, age: (nowMs-dashStartMs)});
    }
    for(let i=trail.length-1;i>=0;i--){ trail[i].age += dt*1000; if(trail[i].age>140) trail.splice(i,1); }
    for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.x+=p.vx*dt; p.y+=p.vy*dt; p.vx*=0.98; p.vy*=0.98; p.life-=dt*1000; if(p.life<=0) particles.splice(i,1); }

    // Integrate
    let nx=player.x + player.vx*dt, ny=player.y + player.vy*dt;

    // Collide Y with rects
    let grounded=false;
    const boxY={x:nx,y:ny,w:player.w,h:player.h};
    for(const p of L.pads){
      if(p.t==='rect'){
        if(!(boxY.x < p.x + p.w && boxY.x + boxY.w > p.x && boxY.y < p.y + p.h && boxY.y + boxY.h > p.y)) continue;
        if(player.vy>0){ ny=p.y - player.h; player.vy=0; grounded=true; }
        else if(player.vy<0){ ny=p.y + p.h; player.vy=0; }
        boxY.y=ny;
      }
    }
    // Slopes as ground
    const feetX = nx + player.w*0.5;
    for(const p of L.pads){
      if(p.t!=='slope') continue;
      if(feetX < p.minX || feetX > p.maxX) continue;
      const ySurf = slopeYAt(p, feetX);
      if (ny + player.h >= ySurf - 0.5 && player.vy >= 0){ ny = ySurf - player.h; player.vy=0; grounded=true; }
    }

    // Moving platforms collision + carry
    // 1) check standing on top
    for(const m of L.plats){
      const topRect = {x:m.x, y:m.y-2, w:m.w, h:6}; // a thin band above
      const pxTop = {x:nx, y:ny+player.h-2, w:player.w, h:4};
      const overTop = (pxTop.x < topRect.x+topRect.w && pxTop.x+pxTop.w > topRect.x && pxTop.y < topRect.y+topRect.h && pxTop.y+pxTop.h > topRect.y);
      if (overTop && player.vy>=0){
        ny = m.y - player.h; player.vy = 0; grounded = true;
        // carry by platform delta
        const dx = m.x - m.prevX, dy = m.y - m.prevY;
        nx += dx; ny += dy;
      }
      // 2) no-crush: if platform moved into player from side or above, nudge out
      const platBox = {x:m.x, y:m.y, w:m.w, h:m.h};
      const pbox = {x:nx, y:ny, w:player.w, h:player.h};
      const overlap = !(pbox.x > platBox.x+platBox.w || pbox.x+pbox.w < platBox.x || pbox.y > platBox.y+platBox.h || pbox.y+pbox.h < platBox.y);
      if (overlap){
        // Resolve along smallest penetration
        const dxLeft = (pbox.x + pbox.w) - platBox.x;
        const dxRight = (platBox.x + platBox.w) - pbox.x;
        const dyTop = (pbox.y + pbox.h) - platBox.y;
        const dyBottom = (platBox.y + platBox.h) - pbox.y;
        const minX = Math.min(dxLeft, dxRight);
        const minY = Math.min(dyTop, dyBottom);
        if (minX < minY){
          if (dxLeft < dxRight) nx -= dxLeft; else nx += dxRight;
          player.vx = 0;
        } else {
          if (dyTop < dyBottom){ ny -= dyTop; player.vy=0; grounded = true; }
          else { ny += dyBottom; player.vy=0; }
        }
      }
    }

    // Collide X with rects (after platforms)
    const boxX={x:nx,y:ny,w:player.w,h:player.h};
    for(const p of L.pads){
      if(p.t==='rect'){
        if(!(boxX.x < p.x + p.w && boxX.x + boxX.w > p.x && boxX.y < p.y + p.h && boxX.y + p.h > p.y)) continue;
        if(player.vx>0){ nx=p.x - player.w; player.vx=0; }
        else if(player.vx<0){ nx=p.x + p.w; player.vx=0; }
        boxX.x=nx;
      }
    }

    player.x=nx; player.y=ny; player.onGround=grounded;

    // Hazards/enemies (kept, though Level 5 has none)
    const px={x:player.x,y:player.y,w:player.w,h:player.h};
    function hit(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
    let died=false;
    for(const h of L.hz){
      if(h.t==='spike'){
        const hb={x:h.x,y:h.y - h.h, w:h.w, h:h.h};
        if(hit(px,hb)) { died=true; break; }
      } else if(h.t==='laser'){
        const hb={x:(h.axis==='x'?(h.x + (h.offset||0)):h.x),
                  y:(h.axis==='y'?(h.y + (h.offset||0)):h.y), w:h.w, h:h.h};
        if(hit(px,hb)) { died=true; break; }
      }
    }
    if(!died){
      for(const e of L.en){
        const hb={x:e.x,y:e.y,w:e.w,h:e.h};
        if(hit(px,hb)) { died=true; break; }
      }
    }
    if(died){ respawn(false, true); }

    // Goal
    const g = L.goal;
    if(hit(px, g)){
      const sec = (performance.now() - run.timeStart)/1000;
      overlay.style.display='flex';
      ovTitle.textContent = (levelIndex===LEVELS.length-1) ? 'Run Complete!' : `Level ${levelIndex+1} Complete!`;
      ovBody.textContent  = `Time: ${sec.toFixed(2)}s • Deaths: ${run.deaths}`;
      ovScore.textContent = '';
      nextBtn.onclick = ()=>{
        overlay.style.display='none';
        if(levelIndex < LEVELS.length-1){ startLevel(++levelIndex); } else { startLevel(0); }
      };
      retryBtn.onclick = ()=>{ overlay.style.display='none'; startLevel(levelIndex); };
      return requestAnimationFrame(step);
    }

    // Fall respawn
    if (player.y > groundY + 900){ respawn(false, true); }

    // Camera
    const viewW = canvas.width / DPR;
    const baseLA = LOOK_BASE + Math.abs(player.vx)*LOOK_SPEED_FACTOR + (player.onGround?0:LOOK_AIR_BONUS);
    const maxLA = (player.onGround ? viewW*0.28 : viewW*0.34);
    let targetLA = baseLA * (player.facing>=0 ? 1 : -1);
    targetLA = Math.max(-maxLA, Math.min(maxLA, targetLA));
    lookAhead += (targetLA - lookAhead) * Math.min(1, dt*LOOK_SMOOTH);
    camX += ((player.x + lookAhead) - camX) * Math.min(1, dt*LOOK_SMOOTH);
    camY += ((player.y - 80) - camY) * Math.min(1, dt*LOOK_SMOOTH);

    render(L);
    requestAnimationFrame(step);
  }

  function glowRect(x,y,w,h,c,a){
    ctx.globalAlpha=a; ctx.fillStyle=c; ctx.fillRect(x,y,w,h);
    const g=ctx.createRadialGradient(x+w/2,y+h/2, Math.min(w,h)/4, x+w/2,y+h/2, Math.max(w,h));
    g.addColorStop(0, c+'cc'); g.addColorStop(1, c+'00');
    ctx.fillStyle=g; ctx.fillRect(x-h, y-h, w+2*h, h+2*h); ctx.globalAlpha=1;
  }
  function drawSlope(s,c){
    const steps=10;
    for(let i=0;i<steps;i++){ const t0=i/steps, t1=(i+1)/steps;
      const x0=s.x1+(s.x2-s.x1)*t0, y0=s.y1+(s.y2-s.y1)*t0;
      const x1=s.x1+(s.x2-s.x1)*t1, y1=s.y1+(s.y2-s.y1)*t1;
      glowRect(x0, Math.min(y0,y1)-6, (x1-x0), 6, c, 1); }
  }

  function render(L){
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // BG grid
    const s=32*DPR, gx=-(camX%s), gy=-(camY%s);
    ctx.globalAlpha=0.08; ctx.strokeStyle='#0bd7'; ctx.beginPath();
    for(let x=gx;x<canvas.width;x+=s){ ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
    for(let y=gy;y<canvas.height;y+=s){ ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
    ctx.stroke(); ctx.globalAlpha=1;

    const viewX = Math.floor(camX - canvas.width/(2*DPR));
    const viewY = Math.floor(camY - canvas.height/(2*DPR));
    ctx.save(); ctx.translate(-viewX,-viewY);

    // Pads
    for(const p of L.pads){ if(p.t==='rect') glowRect(p.x,p.y,p.w,p.h,'#39d2ff',1); else drawSlope(p,'#39d2ff'); }
    // Moving platforms (visible)
    if (L.plats){
      for(const m of L.plats){ glowRect(m.x, m.y, m.w, m.h, '#8ee3ff', 0.95); }
    }
    // Hazards
    for(const h of L.hz){
      if(h.t==='spike'){
        ctx.fillStyle = '#39d2ff';
        const baseY=h.y, triW = h.w/3;
        for(let i=0;i<3;i++){
          const x0=h.x + i*triW, x1=x0+triW/2, x2=x0+triW;
          ctx.beginPath(); ctx.moveTo(x0, baseY); ctx.lineTo(x2, baseY); ctx.lineTo(x1, baseY - h.h); ctx.closePath(); ctx.fill();
        }
      } else if(h.t==='laser'){
        const ox = (h.axis==='x') ? (h.offset||0) : 0;
        const oy = (h.axis==='y') ? (h.offset||0) : 0;
        glowRect(h.x+ox, h.y+oy, h.w, h.h, '#ff6fa6', 0.9);
      }
    }
    // Enemies
    for(const e of L.en){ glowRect(e.x, e.y, e.w, e.h, '#ffe066', 0.95); }
    // Goal
    const g=L.goal; const t = performance.now()/1000;
    const cx=g.x + g.w/2, cy=g.y + g.h/2;
    glowRect(g.x, g.y, g.w, g.h, '#9ffff0', 1.0);
    ctx.save(); ctx.translate(cx, cy); ctx.rotate(t*0.9);
    const ringR = 56 + 12*Math.sin(t*3.2);
    ctx.globalAlpha = 0.95; ctx.strokeStyle = '#c9fff7'; ctx.lineWidth = 6;
    ctx.beginPath(); ctx.arc(0,0, ringR, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
    const beamW = 14 + 6*Math.sin(t*5.0);
    glowRect(cx - beamW/2, cy - 260, beamW, 520, '#c9fff7', 0.42);

    // Player
    glowRect(player.x, player.y, player.w, player.h, dashCooldown>0 ? '#ff6fa6' : '#7fffd4', 1);

    // Screen flash
    if(screenFlash>0){
      const a = Math.min(0.45, screenFlash/140*0.45);
      ctx.setTransform(1,0,0,1,0,0);
      ctx.globalAlpha=a; ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.globalAlpha=1; screenFlash -= (1000/60);
    }

    ctx.restore();
  }

  requestAnimationFrame(step);
})();
</script>
</body>
</html>
