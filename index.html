<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Neon Realms — Levels 1–5</title>
<style>
  html,body{height:100%;margin:0;background:#0a0a12;color:#e8f0ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif}
  canvas{display:block;width:100vw;height:100vh;touch-action:none}
  #hud{position:fixed;left:8px;top:8px;z-index:11;background:#101022;border:1px solid #2b2b64;border-radius:10px;padding:8px 10px;font-size:12px;opacity:.96;min-width:220px}
  #hud .row{display:flex;justify-content:space-between;gap:10px;align-items:center}
  #buttons{position:fixed;left:12px;bottom:16px;display:flex;gap:8px;z-index:10}
  .btn{width:64px;height:64px;border-radius:14px;border:1px solid #2b2b64;background:radial-gradient(100% 100% at 50% 0%,#1a1a36 0%,#0e0e1f 100%);color:#bfe2ff;font-weight:800;font-size:10px}
  #dashBtn{position:fixed;right:12px;bottom:88px;width:64px;height:64px;border-radius:14px;border:1px solid #2b2b64;background:radial-gradient(100% 100% at 50% 0%,#1a1a36 0%,#0e0e1f 100%);color:#bfe2ff;font-weight:800;font-size:10px;display:block;z-index:10}
  #jumpBtn{position:fixed;right:12px;bottom:16px}
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="hud">
  <div class="row"><span id="levelLbl">Level 1/5</span><span id="dashLbl">Dash: READY</span></div>
  <div class="row"><span id="deathLbl">Deaths: 0</span><span id="timerLbl">Time: 0.00</span></div>
</div>

<div id="buttons">
  <button class="btn" id="leftBtn">LEFT</button>
  <button class="btn" id="rightBtn">RIGHT</button>
  <button class="btn" id="jumpBtn">JUMP</button>
</div>
<button class="btn" id="dashBtn">DASH</button>

<script>
(() => {
  // Canvas
  const DPR=Math.max(1,Math.min(2,devicePixelRatio||1));
  const cvs=document.getElementById('game'), ctx=cvs.getContext('2d',{alpha:false});
  const resize=()=>{cvs.width=Math.floor(innerWidth*DPR); cvs.height=Math.floor(innerHeight*DPR);};
  addEventListener('resize',resize); resize();

  // HUD
  const levelLbl=document.getElementById('levelLbl'), dashLbl=document.getElementById('dashLbl'),
        deathLbl=document.getElementById('deathLbl'), timerLbl=document.getElementById('timerLbl');

  // Input
  const keys={left:false,right:false,jump:false}; let jumpEdge=false,lastJumpTapMs=-1;
  const setKey=(k,v)=>keys[k]=v, tapJump=()=>{jumpEdge=true; lastJumpTapMs=performance.now();};
  function bindHold(el,key){
    el.addEventListener('pointerdown',e=>{e.preventDefault(); setKey(key,true); if(key==='jump') tapJump();},{passive:false});
    el.addEventListener('pointerup',e=>{e.preventDefault(); setKey(key,false);},{passive:false});
    el.addEventListener('touchstart',e=>{e.preventDefault(); setKey(key,true); if(key==='jump') tapJump();},{passive:false});
    el.addEventListener('touchend',e=>{e.preventDefault(); setKey(key,false);},{passive:false});
  }
  bindHold(document.getElementById('leftBtn'),'left');
  bindHold(document.getElementById('rightBtn'),'right');
  bindHold(document.getElementById('jumpBtn'),'jump');
  document.getElementById('dashBtn').addEventListener('pointerup',e=>{e.preventDefault(); tryDash(player.facing||1);});
  addEventListener('keydown',e=>{ if(e.repeat) return;
    if(e.code==='ArrowLeft'||e.code==='KeyA') setKey('left',true);
    if(e.code==='ArrowRight'||e.code==='KeyD') setKey('right',true);
    if(e.code==='Space'||e.code==='KeyW'||e.code==='ArrowUp'){ setKey('jump',true); tapJump(); }
    if(e.code==='ShiftLeft'||e.code==='ShiftRight') tryDash(player.facing||1);
  });
  addEventListener('keyup',e=>{
    if(e.code==='ArrowLeft'||e.code==='KeyA') setKey('left',false);
    if(e.code==='ArrowRight'||e.code==='KeyD') setKey('right',false);
    if(e.code==='Space'||e.code==='KeyW'||e.code==='ArrowUp') setKey('jump',false);
  });

  // World helpers
  const groundY=520;
  const rect=(x,y,w,h)=>({t:'rect',x,y,w,h});
  const slope=(x1,y1,x2,y2)=>({t:'slope',x1,y1,x2,y2,minX:Math.min(x1,x2),maxX:Math.max(x1,x2)});
  const slopeYAt=(s,x)=>{const t=(x-s.x1)/(s.x2-s.x1); return s.y1+t*(s.y2-s.y1);};
  const spike=(x,y,w,h)=>({t:'spike',x,y,w,h});
  const laser=(x,y,w,h,axis='y',amp=0,speed=0)=>({t:'laser',x,y,w,h,axis,amp,speed,phase:Math.random()*Math.PI*2});
  const drone=(x,y,minX,maxX,speed)=>({t:'drone',x,y,w:36,h:24,minX,maxX,dir:1,speed});
  const goal=(x,y)=>({t:'goal',x,y,w:36,h:120});
  const mplat=(x,y,w,h,axis,min,max,speed,pause=0.2)=>({t:'mplat',x,y,w,h,axis,min,max,speed,dir:1,pause,waiting:0,prevX:x,prevY:y});

  // Levels 1–4 (trimmed, same vibe)
  function L1(){ const p=[],h=[],e=[]; let x=40; while(x<3600){const w=420,g=140;p.push(rect(x,groundY,w,30)); x+=w+g;}
    p.push(slope(900,groundY+30,1080,groundY-140)); p.push(rect(1400,groundY-110,220,18)); p.push(rect(1900,groundY-200,220,18));
    h.push(spike(1200,groundY,80,40)); h.push(laser(2200,groundY-170,18,170,'y',80,1.1));
    e.push(drone(1650,groundY-140,1600,1850,120)); return {pads:p,hz:h,en:e,goal:goal(3300,groundY-120),length:3600,plats:[]}; }
  function L2(){ const p=[],h=[],e=[]; let x=40; while(x<4200){const w=360,g=160;p.push(rect(x,groundY,w,30)); x+=w+g;}
    p.push(slope(700,groundY+30,900,groundY-160)); p.push(rect(1350,groundY-140,200,18)); p.push(rect(1700,groundY-260,200,18)); p.push(rect(2300,groundY-100,220,18));
    h.push(spike(1100,groundY,100,40)); h.push(laser(2000,groundY-180,18,220,'y',120,1.5)); h.push(laser(2600,groundY-40,220,16,'x',100,1.0));
    e.push(drone(1500,groundY-170,1450,1750,150)); return {pads:p,hz:h,en:e,goal:goal(3900,groundY-120),length:4200,plats:[]}; }
  function L3(){ const p=[],h=[],e=[]; let x=40; while(x<4800){const w=320,g=180;p.push(rect(x,groundY,w,30)); x+=w+g;}
    p.push(slope(900,groundY+30,1080,groundY-180)); p.push(rect(1500,groundY-180,200,18)); p.push(rect(1900,groundY-300,200,18)); p.push(rect(2550,groundY-220,200,18));
    h.push(spike(1250,groundY,120,40)); h.push(laser(2100,groundY-200,18,240,'y',140,1.6)); h.push(laser(3000,groundY-60,260,16,'x',160,1.2));
    e.push(drone(1700,groundY-210,1650,1950,170)); return {pads:p,hz:h,en:e,goal:goal(4500,groundY-120),length:4800,plats:[]}; }
  function L4(){ const p=[],h=[],e=[]; let x=40; while(x<5200){const w=340,g=190;p.push(rect(x,groundY,w,30)); x+=w+g;}
    p.push(slope(820,groundY+30,1040,groundY-160)); p.push(rect(1320,groundY-140,200,18)); p.push(rect(2100,groundY-180,200,18)); p.push(rect(2480,groundY-260,200,18));
    h.push(spike(1200,groundY,100,40)); h.push(laser(2200,groundY-200,18,220,'y',120,1.45));
    e.push(drone(1750,groundY-170,1700,1950,150)); return {pads:p,hz:h,en:e,goal:goal(4900,groundY-120),length:5200,plats:[]}; }

  // Level 5 — moving platforms + hazards
  function L5(){
    const p=[],h=[],e=[], plats=[];
    p.push(rect(40,groundY,520,30)); p.push(rect(1500,groundY,520,30));
    p.push(rect(1150,groundY-140,200,18)); p.push(rect(1750,groundY-120,220,18)); p.push(rect(1980,groundY-220,200,18));
    h.push(spike(880,groundY,260,44));
    h.push(laser(1660,groundY-230,18,240,'y',120,1.35));
    plats.push(mplat(780,groundY-86,190,20,'x',700,1280,110,0.22));
    plats.push(mplat(1620,groundY-180,160,20,'y',groundY-290,groundY-120,95,0.20));
    e.push(drone(1880,groundY-170,1820,2020,145));
    return {pads:p,hz:h,en:e,goal:goal(2120,groundY-220),length:2300,plats};
  }

  const LEVELS=[L1(),L2(),L3(),L4(),L5()];
  let levelIndex=0; const L=()=>LEVELS[levelIndex];

  // Player/physics
  const player={x:120,y:420,w:30,h:36,vx:0,vy:0,onGround:false,facing:1};
  const MOVE=360,G=2200,JUMP=780; let coyote=0;
  const DASH_SPEED=1700,DASH_COOLDOWN=0.85,DJ_MIN=0.06,DJ_MAX=0.30,DJ_BOOST=300;
  let dashCooldown=0,dashStartMs=-1,djDone=false; const trail=[]; let screenFlash=0;

  const tryDash=(dir)=>{ if(dashCooldown>0)return; player.vx=dir*DASH_SPEED; dashCooldown=DASH_COOLDOWN; dashStartMs=performance.now(); djDone=false; };
  let run={deaths:0,timeStart:performance.now()};
  const respawn=(start=false,death=false)=>{ player.x=120; player.y=420; player.vx=0; player.vy=0; player.onGround=false; coyote=0;
    if(death){ run.deaths++; deathLbl.textContent='Deaths: '+run.deaths; screenFlash=140; }
    if(start){ camX=player.x; camY=groundY-120; } };
  let camX=0,camY=groundY-120,look=0,last=performance.now();
  function startLevel(i){ levelIndex=Math.max(0,Math.min(LEVELS.length-1,i)); levelLbl.textContent=`Level ${levelIndex+1}/${LEVELS.length}`;
    respawn(true); run.deaths=0; run.timeStart=performance.now(); deathLbl.textContent='Deaths: 0'; } startLevel(0);

  function updHaz(dt,hz){ for(const h of hz) if(h.t==='laser'){ const t=performance.now()/1000+(h.phase||0); h.offset=Math.sin(t*h.speed)*h.amp; } }
  function updEn(dt,en){ for(const d of en){ d.x+=d.dir*(d.speed||0)*dt; if(d.x<d.minX){d.x=d.minX; d.dir=1;} if(d.x+d.w>d.maxX){d.x=d.maxX-d.w; d.dir=-1;} } }
  function updPl(dt,pl){ for(const p of pl){ p.prevX=p.x; p.prevY=p.y; if(p.waiting>0){p.waiting-=dt;continue;}
      if(p.axis==='x'){ p.x+=p.dir*p.speed*dt; if(p.x<p.min){p.x=p.min;p.dir=1;p.waiting=p.pause;} if(p.x>p.max){p.x=p.max;p.dir=-1;p.waiting=p.pause;} }
      else { p.y+=p.dir*p.speed*dt; if(p.y<p.min){p.y=p.min;p.dir=1;p.waiting=p.pause;} if(p.y>p.max){p.y=p.max;p.dir=-1;p.waiting=p.pause;} } } }

  function step(now){
    const dt=Math.min(0.033,(now-last)/1000); last=now;
    timerLbl.textContent='Time: '+((now-run.timeStart)/1000).toFixed(2);
    dashCooldown=Math.max(0,dashCooldown-dt); dashLbl.textContent='Dash: '+(dashCooldown>0?dashCooldown.toFixed(1)+'s':'READY');

    const dir=(keys.right?1:0)-(keys.left?1:0); if(dir!==0) player.facing=dir;
    player.vx+=(dir*MOVE-player.vx)*0.30; player.vy+=G*dt;
    if(player.onGround) coyote=0.12; else coyote=Math.max(0,coyote-dt);
    if(jumpEdge&&(player.onGround||coyote>0)){ player.vy=-JUMP; coyote=0; } jumpEdge=false;
    const djDelta=(lastJumpTapMs>0&&dashStartMs>0)?(lastJumpTapMs-dashStartMs):-1e9;
    if(!djDone && djDelta>=DJ_MIN*1000 && djDelta<=DJ_MAX*1000){ player.vy=Math.min(player.vy,0)-DJ_BOOST; djDone=true; }

    updHaz(dt,L().hz); updEn(dt,L().en); updPl(dt,L().plats||[]);
    let nx=player.x+player.vx*dt, ny=player.y+player.vy*dt;

    // collide Y with rects
    let grounded=false; const boxY={x:nx,y:ny,w:player.w,h:player.h};
    for(const p of L().pads){ if(p.t!=='rect') continue;
      if(!(boxY.x<p.x+p.w && boxY.x+boxY.w>p.x && boxY.y<p.y+p.h && boxY.y+boxY.h>p.y)) continue;
      if(player.vy>0){ ny=p.y-player.h; player.vy=0; grounded=true; } else if(player.vy<0){ ny=p.y+p.h; player.vy=0; } boxY.y=ny; }
    // slopes
    const feetX=nx+player.w*0.5;
    for(const s of L().pads){ if(s.t!=='slope') continue; if(feetX<s.minX||feetX>s.maxX) continue;
      const yS=slopeYAt(s,feetX); if(ny+player.h>=yS-0.5 && player.vy>=0){ ny=yS-player.h; player.vy=0; grounded=true; } }
    // platforms stand/carry + resolve
    for(const m of (L().plats||[])){
      const top={x:m.x,y:m.y-2,w:m.w,h:6}, pxTop={x:nx,y:ny+player.h-2,w:player.w,h:4};
      const over=(pxTop.x<top.x+top.w && pxTop.x+pxTop.w>top.x && pxTop.y<top.y+top.h && pxTop.y+pxTop.h>top.y);
      if(over && player.vy>=0){ ny=m.y-player.h; player.vy=0; grounded=true; nx+=m.x-m.prevX; ny+=m.y-m.prevY; }
      const pb={x:m.x,y:m.y,w:m.w,h:m.h}, me={x:nx,y:ny,w:player.w,h:player.h};
      const ov=!(me.x>pb.x+pb.w||me.x+me.w<pb.x||me.y>pb.y+pb.h||me.y+me.h<pb.y);
      if(ov){ const dxL=me.x+me.w-pb.x, dxR=pb.x+pb.w-me.x, dyT=me.y+me.h-pb.y, dyB=pb.y+pb.h-me.y;
        if(Math.min(dxL,dxR)<Math.min(dyT,dyB)){ if(dxL<dxR) nx-=dxL; else nx+=dxR; player.vx=0; }
        else { if(dyT<dyB){ ny-=dyT; player.vy=0; grounded=true; } else { ny+=dyB; player.vy=0; } } }
    }
    // collide X with rects
    const boxX={x:nx,y:ny,w:player.w,h:player.h};
    for(const p of L().pads){ if(p.t!=='rect') continue;
      if(!(boxX.x<p.x+p.w && boxX.x+boxX.w>p.x && boxX.y<p.y+p.h && boxX.y+p.h>p.y)) continue;
      if(player.vx>0){ nx=p.x-player.w; player.vx=0; } else if(player.vx<0){ nx=p.x+p.w; player.vx=0; } boxX.x=nx; }

    player.x=nx; player.y=ny; player.onGround=grounded;

    // hazards/enemies
    const me={x:player.x,y:player.y,w:player.w,h:player.h};
    const hit=(a,b)=>a.x<b.x+b.w&&a.x+a.w>b.x&&a.y<b.y+b.h&&a.y+a.h>b.y;
    let died=false;
    for(const h of L().hz){
      if(h.t==='spike'){ const hb={x:h.x,y:h.y-h.h,w:h.w,h:h.h}; if(hit(me,hb)){died=true;break;} }
      else if(h.t==='laser'){ const hb={x:(h.axis==='x'?(h.x+(h.offset||0)):h.x),y:(h.axis==='y'?(h.y+(h.offset||0)):h.y),w:h.w,h:h.h}; if(hit(me,hb)){died=true;break;} }
    }
    if(!died){ for(const d of L().en){ if(hit(me,d)){died=true;break;} } }
    if(died) respawn(false,true);

    // goal
    const g=L().goal; if(hit(me,g)){ const sec=(performance.now()-run.timeStart)/1000;
      alert(`Level ${levelIndex+1} Complete!  Time: ${sec.toFixed(2)}s  Deaths: ${run.deaths}`);
      levelIndex=(levelIndex+1)%LEVELS.length; startLevel(levelIndex); return requestAnimationFrame(step); }

    if(player.y>groundY+900) respawn(false,true);

    // camera
    const viewW=cvs.width/DPR, baseLA=140+Math.abs(player.vx)*0.35+(player.onGround?0:80);
    const maxLA=(player.onGround?viewW*0.28:viewW*0.34); let target=baseLA*(player.facing>=0?1:-1);
    target=Math.max(-maxLA,Math.min(maxLA,target)); look+=(target-look)*Math.min(1,dt*7);
    camX+=((player.x+look)-camX)*Math.min(1,dt*7); camY+=((player.y-80)-camY)*Math.min(1,dt*7);

    // render
    ctx.setTransform(DPR,0,0,DPR,0,0); ctx.clearRect(0,0,cvs.width,cvs.height);
    const s=32*DPR,gx=-(camX%s),gy=-(camY%s); ctx.globalAlpha=.08; ctx.strokeStyle='#0bd7'; ctx.beginPath();
    for(let x=gx;x<cvs.width;x+=s){ctx.moveTo(x,0);ctx.lineTo(x,cvs.height);} for(let y=gy;y<cvs.height;y+=s){ctx.moveTo(0,y);ctx.lineTo(cvs.width,y);} ctx.stroke(); ctx.globalAlpha=1;
    const vx=Math.floor(camX-cvs.width/(2*DPR)), vy=Math.floor(camY-cvs.height/(2*DPR)); ctx.save(); ctx.translate(-vx,-vy);
    const glow=(x,y,w,h,c,a)=>{ctx.globalAlpha=a; ctx.fillStyle=c; ctx.fillRect(x,y,w,h); const g=ctx.createRadialGradient(x+w/2,y+h/2,Math.min(w,h)/4,x+w/2,y+h/2,Math.max(w,h)); g.addColorStop(0,c+'cc'); g.addColorStop(1,c+'00'); ctx.fillStyle=g; ctx.fillRect(x-h,y-h,w+2*h,h+2*h); ctx.globalAlpha=1;};
    for(const p of L().pads){ if(p.t==='rect') glow(p.x,p.y,p.w,p.h,'#39d2ff',1); else { const s=p; const st=10; for(let i=0;i<st;i++){const t0=i/st,t1=(i+1)/st; const x0=s.x1+(s.x2-s.x1)*t0,y0=s.y1+(s.y2-s.y1)*t0,x1=s.x1+(s.x2-s.x1)*t1,y1=s.y1+(s.y2-s.y1)*t1; glow(x0,Math.min(y0,y1)-6,(x1-x0),6,'#39d2ff',1);} } }
    for(const m of (L().plats||[])) glow(m.x,m.y,m.w,m.h,'#8ee3ff',.95);
    for(const h of L().hz){ if(h.t==='spike'){ ctx.fillStyle='#39d2ff'; const base=h.y,tw=h.w/3; for(let i=0;i<3;i++){const x0=h.x+i*tw,x1=x0+tw/2,x2=x0+tw; ctx.beginPath(); ctx.moveTo(x0,base); ctx.lineTo(x2,base); ctx.lineTo(x1,base-h.h); ctx.closePath(); ctx.fill();}}
      else{ const ox=(h.axis==='x')?(h.offset||0):0, oy=(h.axis==='y')?(h.offset||0):0; glow(h.x+ox,h.y+oy,h.w,h.h,'#ff6fa6',.9);} }
    for(const d of L().en) glow(d.x,d.y,d.w,d.h,'#ffe066',.95);
    const g=L().goal, t=performance.now()/1000, cx=g.x+g.w/2, cy=g.y+g.h/2; glow(g.x,g.y,g.w,g.h,'#9ffff0',1);
    ctx.save(); ctx.translate(cx,cy); ctx.rotate(t*.9); ctx.globalAlpha=.95; ctx.strokeStyle='#c9fff7'; ctx.lineWidth=6; ctx.beginPath(); ctx.arc(0,0,56+12*Math.sin(t*3.2),0,Math.PI*2); ctx.stroke(); ctx.restore();
    glow(cx-(14+6*Math.sin(t*5))/2, cy-260, 14+6*Math.sin(t*5), 520, '#c9fff7', .42);
    glow(player.x,player.y,player.w,player.h, dashCooldown>0?'#ff6fa6':'#7fffd4',1);
    ctx.restore();

    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
